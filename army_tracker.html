<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategic Map Editor</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }
        
        .toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            padding: 10px;
            background: rgba(45, 45, 45, 0.9);
            border-radius: 8px;
            flex-wrap: wrap;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 5px 10px;
            background: #3d3d3d;
            border-radius: 5px;
        }
        
        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        button:hover {
            opacity: 0.8;
        }
        
        .tool-btn {
            background: #4CAF50;
            color: white;
        }
        
        .tool-btn.active {
            background: #45a049;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .action-btn {
            background: #2196F3;
            color: white;
        }
        
        .danger-btn {
            background: #f44336;
            color: white;
        }
        
        select, input {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #4d4d4d;
            color: white;
            font-size: 14px;
        }
        
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            background: none;
        }
        
        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            max-width: 200px;
            font-size: 12px;
        }
        
        .unit-count {
            margin-left: 10px;
            font-size: 12px;
            color: #ccc;
        }
        
        .status {
            margin-top: 10px;
            padding: 5px;
            border-radius: 4px;
            font-size: 12px;
            text-align: center;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .silo-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            z-index: 1000;
            min-width: 150px;
        }
        
        .silo-menu button {
            display: block;
            width: 100%;
            margin: 2px 0;
            padding: 8px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .silo-menu button:hover {
            background: #45a049;
        }
        
        .silo-menu button:disabled {
            background: #666;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="tool-group">
            <button class="tool-btn active" onclick="setTool('army')">ü™ñ Army</button>
            <button class="tool-btn" onclick="setTool('railroad')">üöÇ Railroad</button>
            <button class="tool-btn" onclick="setTool('silo')">üè≠ Silo</button>
            <button class="tool-btn" onclick="setTool('port')">‚öì Port</button>
            <button class="tool-btn" onclick="setTool('move')">‚úã Move</button>
            <button class="tool-btn" onclick="setTool('delete')">üóëÔ∏è Delete</button>
        </div>
        
        <div class="tool-group">
            <button class="action-btn" onclick="zoomIn()">üîç+ Zoom In</button>
            <button class="action-btn" onclick="zoomOut()">üîç- Zoom Out</button>
            <button class="action-btn" onclick="resetView()">üéØ Reset View</button>
        </div>
        
        <div class="tool-group">
            <label>Army:</label>
            <select id="armyBattalions">
                <option value="1">1 Battalion (Black)</option>
                <option value="2">2 Battalions (White)</option>
                <option value="3">3 Battalions (Red)</option>
                <option value="4">4 Battalions (Green)</option>
                <option value="5">5 Battalions (Blue)</option>
            </select>
        </div>
        
        <div class="tool-group">
            <label>Nation:</label>
            <select id="armyNation">
            </select>
        </div>
        
        <div class="tool-group">
            <label>Add Nation:</label>
            <input type="text" id="nationName" placeholder="Nation name" style="width: 100px;">
            <input type="text" id="nationFilename" placeholder="filename (optional)" style="width: 100px;">
            <button class="action-btn" onclick="addNation()">‚ûï Add</button>
            <button class="danger-btn" onclick="removeNation()">‚ûñ Remove</button>
        </div>
        
        <div class="tool-group">
            <button class="action-btn" onclick="saveMap()">üíæ Save</button>
            <button class="action-btn" onclick="loadMap()">üìÅ Load</button>
            <button class="action-btn" onclick="loadBackground()">üñºÔ∏è Background</button>
            <button class="action-btn" onclick="loadFlags()">üè¥ Flags</button>
            <button class="danger-btn" onclick="clearMap()">üóëÔ∏è Clear All</button>
        </div>
        
        <div class="unit-count">
            Armies: <span id="armyCount">0</span> | 
            Railroads: <span id="railroadCount">0</span> | 
            Silos: <span id="siloCount">0</span> | 
            Ports: <span id="portCount">0</span>
        </div>
    </div>
    
    <div class="canvas-container">
        <canvas id="mapCanvas"></canvas>
    </div>
    
    <div class="info-panel">
        <div><strong>Strategic Map Editor</strong></div>
        <div>Current Tool: <span id="currentTool">Army</span></div>
        <div>Middle-click + drag to pan</div>
        <div>Scroll wheel to zoom</div>
        <div>Right-click to delete</div>
        <div>üè¥ Flags: Leave filename empty to auto-use nation name</div>
        <div id="status" class="status"></div>
    </div>
    
    <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="handleFileLoad(event)">

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        
        let currentTool = 'army';
        let isDragging = false;
        let draggedUnit = null;
        let dragOffset = { x: 0, y: 0 };
        let railroadDrawing = false;
        let railroadStart = null;
        let tempRailroad = null;
        let backgroundImage = null;
        let flagImages = {};
        let nationList = [];
        
        // Silo nuke system
        let siloNukes = {};
        let currentSiloMenu = null;
        let nukeDragging = false;
        let nukeFromSilo = null;
        let nukeTargeting = false;
        let targetingSilo = null;
        let explosions = [];
        
        // Camera/view system
        let camera = {
            x: 0,
            y: 0,
            zoom: 1
        };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        let lastMousePos = { x: 0, y: 0 };
        
        // Store all units
        let units = {
            armies: [],
            railroads: [],
            silos: [],
            ports: []
        };
        
        // Unit configurations
        const unitConfig = {
            army: { size: 25, color: 'red' },
            railroad: { size: 25, color: '#8B4513' },
            silo: { size: 18, color: '#666' },
            port: { size: 22, color: '#4169E1' }
        };
        
        function setTool(tool) {
            currentTool = tool;
            document.getElementById('currentTool').textContent = tool.charAt(0).toUpperCase() + tool.slice(1);
            
            // Update button states
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update cursor
            canvas.style.cursor = tool === 'move' ? 'grab' : 'crosshair';
        }
        
        function addNation() {
            const nameInput = document.getElementById('nationName');
            const filenameInput = document.getElementById('nationFilename');
            
            const nationName = nameInput.value.trim();
            let filename = filenameInput.value.trim();
            
            if(!nationName) {
                showStatus('Please enter nation name!', 'error');
                return;
            }
            
            // If no filename provided, use nation name
            if(!filename) {
                filename = nationName;
            }
            
            // Add .png if no extension
            if(!filename.includes('.')) {
                filename += '.png';
            }
            
            // Clean nation key to match flag loading (from filename without extension)
            const nationKey = filename.split('.')[0].toLowerCase().replace(/[^a-z0-9]/g, '');
            
            // Check if nation already exists
            if(nationList.includes(nationKey)) {
                showStatus('Nation already exists!', 'error');
                return;
            }
            
            nationList.push(nationKey);
            
            // Add to dropdown
            const select = document.getElementById('armyNation');
            const option = document.createElement('option');
            option.value = nationKey;
            option.textContent = `${nationName} (${filename})`;
            select.appendChild(option);
            
            // Clear inputs
            nameInput.value = '';
            filenameInput.value = '';
            
            console.log(`Added nation: "${nationName}" with key: "${nationKey}" for file: "${filename}"`);
            showStatus(`Nation "${nationName}" added! Load file: ${filename}`, 'success');
        }
        
        function removeNation() {
            const select = document.getElementById('armyNation');
            const selectedNation = select.value;
            
            if(!selectedNation) {
                showStatus('Please select a nation to remove!', 'error');
                return;
            }
            
            if(confirm(`Remove nation "${selectedNation}" and all its armies?`)) {
                // Remove from nation list
                const index = nationList.indexOf(selectedNation);
                if(index > -1) {
                    nationList.splice(index, 1);
                }
                
                // Remove from dropdown
                const optionToRemove = select.querySelector(`option[value="${selectedNation}"]`);
                if(optionToRemove) {
                    optionToRemove.remove();
                }
                
                // Remove all armies of this nation
                units.armies = units.armies.filter(army => army.nation !== selectedNation);
                
                // Remove flag image
                if(flagImages[selectedNation]) {
                    delete flagImages[selectedNation];
                }
                
                // Reset dropdown selection
                select.selectedIndex = 0;
                
                redraw();
                showStatus(`Nation "${selectedNation}" removed!`, 'success');
            }
        }
        
        function drawUnit(unit, type) {
            ctx.save();
            
            // Apply camera transform
            ctx.translate(-camera.x, -camera.y);
            ctx.scale(camera.zoom, camera.zoom);
            
            switch(type) {
                case 'army':
                    // Get battalion color
                    const battalions = unit.battalions;
                    let armyColor;
                    switch(battalions) {
                        case 1: armyColor = '#000000'; break;
                        case 2: armyColor = '#FFFFFF'; break;
                        case 3: armyColor = '#FF0000'; break;
                        case 4: armyColor = '#00AA00'; break;
                        case 5: armyColor = '#0000FF'; break;
                        default: armyColor = '#000000';
                    }
                    
                    // Get nation flag color (fallback)
                    let flagColor = '#FF0000';
                    
                    // Draw nation flag ON TOP of circle (same width as unit diameter)
                    const flagWidth = unitConfig.army.size * 2; // Same as circle diameter
                    const flagHeight = 25; // Taller flag
                    const flagX = unit.x - flagWidth/2; // Center on unit
                    const flagY = unit.y - unitConfig.army.size - flagHeight - 5; // Above the circle
                    
                    // Always draw flag background first
                    ctx.fillStyle = flagColor;
                    ctx.fillRect(flagX, flagY, flagWidth, flagHeight);
                    
                    // Try to draw flag image if available
                    if(unit.nation && flagImages[unit.nation]) {
                        try {
                            ctx.drawImage(flagImages[unit.nation], flagX, flagY, flagWidth, flagHeight);
                            console.log(`Drawing flag for nation: ${unit.nation}`);
                        } catch(e) {
                            console.error(`Error drawing flag for ${unit.nation}:`, e);
                        }
                    } else {
                        console.log(`No flag image for nation: ${unit.nation}, available flags:`, Object.keys(flagImages));
                    }
                    
                    // Flag border
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1 / camera.zoom;
                    ctx.strokeRect(flagX, flagY, flagWidth, flagHeight);
                    
                    // Draw army unit circle ON TOP of flag
                    ctx.fillStyle = armyColor;
                    ctx.strokeStyle = armyColor === '#FFFFFF' ? '#000' : '#FFF';
                    ctx.lineWidth = 2 / camera.zoom;
                    
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, unitConfig.army.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Battalion number (larger text)
                    if(camera.zoom > 0.3) {
                        ctx.fillStyle = armyColor === '#FFFFFF' || armyColor === '#FFFF00' ? '#000' : '#FFF';
                        ctx.font = `bold ${18 / camera.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(battalions, unit.x, unit.y + 6);
                    }
                    break;
                    
                case 'railroad':
                    const dx = unit.endX - unit.startX;
                    const dy = unit.endY - unit.startY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if(length > 0) {
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = 8 / camera.zoom;
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(unit.startX, unit.startY);
                        ctx.lineTo(unit.endX, unit.endY);
                        ctx.stroke();
                    }
                    break;
                    
                case 'silo':
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4 / camera.zoom;
                    
                    // Outer earth rim
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, unitConfig.silo.size + 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#8B4513';
                    ctx.fill();
                    
                    // Inner black hole
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, unitConfig.silo.size, 0, Math.PI * 2);
                    ctx.fillStyle = '#000000';
                    ctx.fill();
                    ctx.stroke();
                    
                    // Depth lines
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1 / camera.zoom;
                    for(let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.arc(unit.x, unit.y, unitConfig.silo.size - (i * 4), 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Show nuke count if any
                    const siloId = unit.x + '_' + unit.y;
                    const nukeCount = siloNukes[siloId] || 0;
                    if(nukeCount > 0 && camera.zoom > 0.3) {
                        ctx.fillStyle = '#FF0000';
                        ctx.font = `bold ${12 / camera.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(nukeCount, unit.x, unit.y - unitConfig.silo.size - 8);
                    }
                    
                    // Show targeting range if this silo is targeting
                    if(nukeTargeting && targetingSilo && targetingSilo.x === unit.x && targetingSilo.y === unit.y) {
                        ctx.strokeStyle = 'rgba(255, 165, 0, 0.5)';
                        ctx.lineWidth = 3 / camera.zoom;
                        ctx.beginPath();
                        ctx.arc(unit.x, unit.y, unitConfig.silo.size * 50, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    break;
                    
                case 'port':
                    ctx.fillStyle = unitConfig.port.color;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2 / camera.zoom;
                    
                    ctx.fillRect(unit.x - 15, unit.y - 10, 30, 20);
                    ctx.strokeRect(unit.x - 15, unit.y - 10, 30, 20);
                    
                    // Port crane
                    ctx.beginPath();
                    ctx.moveTo(unit.x - 10, unit.y - 10);
                    ctx.lineTo(unit.x - 10, unit.y - 25);
                    ctx.lineTo(unit.x + 10, unit.y - 25);
                    ctx.stroke();
                    break;
            }
            
            ctx.restore();
        }
        
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            ctx.scale(camera.zoom, camera.zoom);
            
            if(backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0);
                
                // Draw border
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3 / camera.zoom;
                ctx.strokeRect(0, 0, backgroundImage.width, backgroundImage.height);
            }
            
            ctx.restore();
            
            // Draw all units
            units.armies.forEach(unit => drawUnit(unit, 'army'));
            units.railroads.forEach(unit => drawUnit(unit, 'railroad'));
            units.silos.forEach(unit => drawUnit(unit, 'silo'));
            units.ports.forEach(unit => drawUnit(unit, 'port'));
            
            if(tempRailroad) {
                drawUnit(tempRailroad, 'railroad');
            }
            
            // Draw explosions
            explosions.forEach(explosion => {
                const age = Date.now() - explosion.startTime;
                const maxAge = 3000;
                if(age < maxAge) {
                    const alpha = 1 - (age / maxAge);
                    const size = (age / maxAge) * 100 + 20;
                    
                    ctx.save();
                    ctx.translate(-camera.x, -camera.y);
                    ctx.scale(camera.zoom, camera.zoom);
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#FF4500';
                    ctx.strokeStyle = '#FF0000';
                    ctx.lineWidth = 3 / camera.zoom;
                    
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.restore();
                }
            });
            
            // Remove old explosions
            explosions = explosions.filter(explosion => Date.now() - explosion.startTime < 3000);
            
            // Draw dragging nuke icon
            if(nukeDragging || nukeTargeting) {
                const mousePos = lastMousePos || { x: 0, y: 0 };
                ctx.fillStyle = '#FF0000';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Nuke symbol
                ctx.fillStyle = '#FFFF00';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('‚ò¢', mousePos.x, mousePos.y + 4);
            }
            
            updateCounts();
        }
        
        function updateCounts() {
            document.getElementById('armyCount').textContent = units.armies.length;
            document.getElementById('railroadCount').textContent = units.railroads.length;
            document.getElementById('siloCount').textContent = units.silos.length;
            document.getElementById('portCount').textContent = units.ports.length;
        }
        
        function constrainCamera() {
            if(!backgroundImage) return;
            
            const imageWidth = backgroundImage.width;
            const imageHeight = backgroundImage.height;
            const viewWidth = canvas.width / camera.zoom;
            const viewHeight = canvas.height / camera.zoom;
            
            const minX = 0;
            const minY = 0;
            const maxX = Math.max(0, imageWidth - viewWidth);
            const maxY = Math.max(0, imageHeight - viewHeight);
            
            camera.x = Math.max(minX, Math.min(maxX, camera.x));
            camera.y = Math.max(minY, Math.min(maxY, camera.y));
        }
        
        function findNearestRailroadEndpoint(x, y, snapDistance = 20) {
            let nearest = null;
            let nearestDistance = snapDistance;
            
            units.railroads.forEach(railroad => {
                const endpoints = [
                    { x: railroad.startX, y: railroad.startY },
                    { x: railroad.endX, y: railroad.endY }
                ];
                
                endpoints.forEach(endpoint => {
                    const distance = Math.sqrt((x - endpoint.x) ** 2 + (y - endpoint.y) ** 2);
                    if(distance < nearestDistance) {
                        nearestDistance = distance;
                        nearest = { x: endpoint.x, y: endpoint.y, railroad: railroad };
                    }
                });
            });
            
            return nearest;
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            return {
                x: (x + camera.x) / camera.zoom,
                y: (y + camera.y) / camera.zoom
            };
        }
        
        function getScreenPos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function findUnitAt(x, y) {
            // Check army units (including flag area)
            for(let i = 0; i < units.armies.length; i++) {
                const army = units.armies[i];
                const circleDistance = Math.sqrt((x - army.x) ** 2 + (y - army.y) ** 2);
                if(circleDistance < unitConfig.army.size) {
                    return { ...army, type: 'armies', index: i };
                }
                
                // Check flag area (updated for taller flag)
                const flagX = army.x - unitConfig.army.size;
                const flagY = army.y - unitConfig.army.size - 20 - 5;
                if(x >= flagX && x <= flagX + (unitConfig.army.size * 2) && y >= flagY && y <= flagY + 20) {
                    return { ...army, type: 'armies', index: i };
                }
            }
            
            // Check other units
            const allUnits = [
                ...units.silos.map(u => ({...u, type: 'silos', index: units.silos.indexOf(u)})),
                ...units.ports.map(u => ({...u, type: 'ports', index: units.ports.indexOf(u)}))
            ];
            
            for(let unit of allUnits) {
                const distance = Math.sqrt((x - unit.x) ** 2 + (y - unit.y) ** 2);
                if(distance < 25) {
                    return unit;
                }
            }
            
            // Check railroads
            for(let i = 0; i < units.railroads.length; i++) {
                const railroad = units.railroads[i];
                const distance = distanceToLineSegment(x, y, railroad.startX, railroad.startY, railroad.endX, railroad.endY);
                if(distance < 15) {
                    return { ...railroad, type: 'railroads', index: i };
                }
            }
            
            return null;
        }
        
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if(lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            if(param < 0) {
                xx = x1;
                yy = y1;
            } else if(param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function placeUnit(x, y, type) {
            const newUnit = { x, y };
            
            switch(type) {
                case 'army':
                    const battalionSelect = document.getElementById('armyBattalions');
                    const nationSelect = document.getElementById('armyNation');
                    newUnit.battalions = battalionSelect ? parseInt(battalionSelect.value) : 1;
                    newUnit.nation = nationSelect ? nationSelect.value : (nationList[0] || 'default');
                    units.armies.push(newUnit);
                    break;
                case 'silo':
                    units.silos.push(newUnit);
                    break;
                case 'port':
                    units.ports.push(newUnit);
                    break;
            }
            
            redraw();
        }
        
        function showSiloMenu(silo, screenX, screenY) {
            closeSiloMenu();
            
            const menu = document.createElement('div');
            menu.className = 'silo-menu';
            menu.style.left = screenX + 'px';
            menu.style.top = screenY + 'px';
            
            const siloId = silo.x + '_' + silo.y;
            const nukeCount = siloNukes[siloId] || 0;
            
            // Add nuke button
            const addBtn = document.createElement('button');
            addBtn.textContent = `Add Nuke (${nukeCount})`;
            addBtn.onclick = () => {
                siloNukes[siloId] = (siloNukes[siloId] || 0) + 1;
                closeSiloMenu();
                redraw();
                showStatus('Nuke added to silo!', 'success');
            };
            menu.appendChild(addBtn);
            
            // Move nuke button
            const moveBtn = document.createElement('button');
            moveBtn.textContent = 'Move Nuke';
            moveBtn.disabled = nukeCount === 0;
            moveBtn.onclick = () => {
                if(nukeCount > 0) {
                    nukeDragging = true;
                    nukeFromSilo = siloId;
                    siloNukes[siloId] = siloNukes[siloId] - 1;
                    closeSiloMenu();
                    redraw();
                    showStatus('Click another silo to move nuke', 'success');
                }
            };
            menu.appendChild(moveBtn);
            
            // Use nuke button
            const useBtn = document.createElement('button');
            useBtn.textContent = 'Use Nuke';
            useBtn.disabled = nukeCount === 0;
            useBtn.onclick = () => {
                if(nukeCount > 0) {
                    nukeTargeting = true;
                    targetingSilo = silo;
                    siloNukes[siloId] = siloNukes[siloId] - 1;
                    closeSiloMenu();
                    redraw();
                    showStatus('Click target location within range', 'success');
                }
            };
            menu.appendChild(useBtn);
            
            document.body.appendChild(menu);
            currentSiloMenu = menu;
        }
        
        function closeSiloMenu() {
            if(currentSiloMenu) {
                document.body.removeChild(currentSiloMenu);
                currentSiloMenu = null;
            }
        }
        
        function createExplosion(x, y) {
            explosions.push({
                x: x,
                y: y,
                startTime: Date.now()
            });
            
            // Remove units in blast radius
            const blastRadius = 50;
            units.armies = units.armies.filter(unit => {
                const distance = Math.sqrt((unit.x - x) ** 2 + (unit.y - y) ** 2);
                return distance > blastRadius;
            });
            
            redraw();
        }
        
        function deleteUnit(unit) {
            if(units[unit.type] && units[unit.type][unit.index]) {
                units[unit.type].splice(unit.index, 1);
                redraw();
            }
        }
        
        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            const screenPos = getScreenPos(e);
            const unit = findUnitAt(pos.x, pos.y);
            
            // Close any open silo menu
            closeSiloMenu();
            
            if(e.button === 2) {
                if(unit) {
                    deleteUnit(unit);
                }
                return;
            }
            
            if(e.button === 1) {
                e.preventDefault();
                isPanning = true;
                lastPanPoint = screenPos;
                canvas.style.cursor = 'grabbing';
                return;
            }
            
            // Handle nuke operations
            if(nukeDragging && unit && unit.type === 'silos') {
                // Move nuke to this silo
                const targetSiloId = unit.x + '_' + unit.y;
                siloNukes[targetSiloId] = (siloNukes[targetSiloId] || 0) + 1;
                nukeDragging = false;
                nukeFromSilo = null;
                redraw();
                showStatus('Nuke moved to silo!', 'success');
                return;
            }
            
            if(nukeTargeting && targetingSilo) {
                // Check if click is within range
                const distance = Math.sqrt((pos.x - targetingSilo.x) ** 2 + (pos.y - targetingSilo.y) ** 2);
                const maxRange = unitConfig.silo.size * 50;
                
                if(distance <= maxRange) {
                    createExplosion(pos.x, pos.y);
                    nukeTargeting = false;
                    targetingSilo = null;
                    showStatus('Nuclear strike launched!', 'success');
                } else {
                    showStatus('Target out of range!', 'error');
                }
                return;
            }
            
            // Handle silo clicks
            if(unit && unit.type === 'silos') {
                showSiloMenu(unit, screenPos.x, screenPos.y);
                return;
            }
            
            if(currentTool === 'railroad') {
                const nearestEndpoint = findNearestRailroadEndpoint(pos.x, pos.y);
                if(nearestEndpoint) {
                    railroadStart = { x: nearestEndpoint.x, y: nearestEndpoint.y };
                } else {
                    railroadStart = { x: pos.x, y: pos.y };
                }
                railroadDrawing = true;
                tempRailroad = {
                    startX: railroadStart.x,
                    startY: railroadStart.y,
                    endX: pos.x,
                    endY: pos.y
                };
            } else if(currentTool === 'move' && unit) {
                isDragging = true;
                draggedUnit = units[unit.type][unit.index];
                if(unit.type === 'railroads') {
                    const centerX = (unit.startX + unit.endX) / 2;
                    const centerY = (unit.startY + unit.endY) / 2;
                    dragOffset.x = pos.x - centerX;
                    dragOffset.y = pos.y - centerY;
                } else {
                    dragOffset.x = pos.x - unit.x;
                    dragOffset.y = pos.y - unit.y;
                }
                canvas.style.cursor = 'grabbing';
            } else if(currentTool === 'delete' && unit) {
                deleteUnit(unit);
            } else if(['army', 'silo', 'port'].includes(currentTool) && !unit) {
                placeUnit(pos.x, pos.y, currentTool);
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            const screenPos = getScreenPos(e);
            lastMousePos = screenPos;
            
            if(isPanning) {
                const deltaX = screenPos.x - lastPanPoint.x;
                const deltaY = screenPos.y - lastPanPoint.y;
                camera.x -= deltaX;
                camera.y -= deltaY;
                constrainCamera();
                lastPanPoint = screenPos;
                redraw();
            } else if(railroadDrawing && tempRailroad) {
                const nearestEndpoint = findNearestRailroadEndpoint(pos.x, pos.y);
                if(nearestEndpoint) {
                    tempRailroad.endX = nearestEndpoint.x;
                    tempRailroad.endY = nearestEndpoint.y;
                } else {
                    tempRailroad.endX = pos.x;
                    tempRailroad.endY = pos.y;
                }
                redraw();
            } else if(isDragging && draggedUnit) {
                if(draggedUnit.startX !== undefined) {
                    const newCenterX = pos.x - dragOffset.x;
                    const newCenterY = pos.y - dragOffset.y;
                    const currentCenterX = (draggedUnit.startX + draggedUnit.endX) / 2;
                    const currentCenterY = (draggedUnit.startY + draggedUnit.endY) / 2;
                    const deltaX = newCenterX - currentCenterX;
                    const deltaY = newCenterY - currentCenterY;
                    
                    draggedUnit.startX += deltaX;
                    draggedUnit.startY += deltaY;
                    draggedUnit.endX += deltaX;
                    draggedUnit.endY += deltaY;
                } else {
                    draggedUnit.x = pos.x - dragOffset.x;
                    draggedUnit.y = pos.y - dragOffset.y;
                }
                redraw();
            } else if(nukeDragging || nukeTargeting) {
                redraw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if(isPanning) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            } else if(railroadDrawing) {
                if(tempRailroad) {
                    const length = Math.sqrt(
                        (tempRailroad.endX - tempRailroad.startX) ** 2 + 
                        (tempRailroad.endY - tempRailroad.startY) ** 2
                    );
                    
                    if(length > 10) {
                        units.railroads.push({
                            startX: tempRailroad.startX,
                            startY: tempRailroad.startY,
                            endX: tempRailroad.endX,
                            endY: tempRailroad.endY
                        });
                    }
                }
                railroadDrawing = false;
                railroadStart = null;
                tempRailroad = null;
                redraw();
            } else if(isDragging) {
                isDragging = false;
                draggedUnit = null;
                canvas.style.cursor = currentTool === 'move' ? 'grab' : 'crosshair';
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const mousePos = getScreenPos(e);
            
            const worldX = (mousePos.x + camera.x) / camera.zoom;
            const worldY = (mousePos.y + camera.y) / camera.zoom;
            
            if(e.deltaY < 0) {
                camera.zoom *= 1.1;
            } else {
                camera.zoom /= 1.1;
            }
            
            camera.zoom = Math.max(0.1, Math.min(camera.zoom, 10));
            
            camera.x = worldX * camera.zoom - mousePos.x;
            camera.y = worldY * camera.zoom - mousePos.y;
            
            constrainCamera();
            redraw();
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        function saveMap() {
            const mapData = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                units: units,
                camera: camera,
                siloNukes: siloNukes,
                nationList: nationList,
                flagImages: Object.keys(flagImages) // Save which flags are available
            };
            
            // Save to localStorage for auto-loading
            localStorage.setItem('strategicMapSave', JSON.stringify(mapData));
            
            // Also download as file
            const blob = new Blob([JSON.stringify(mapData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'strategic_map_save.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus('Map saved to browser and downloaded!', 'success');
        }
        
        function loadMap() {
            document.getElementById('fileInput').click();
        }
        
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if(!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const mapData = JSON.parse(e.target.result);
                    loadMapData(mapData);
                    showStatus('Map loaded successfully!', 'success');
                } catch(error) {
                    showStatus('Error loading file!', 'error');
                }
            };
            reader.readAsText(file);
        }
        
        function loadMapData(mapData) {
            if(mapData.units) {
                units = mapData.units;
                if(mapData.camera) {
                    camera = mapData.camera;
                }
                if(mapData.siloNukes) {
                    siloNukes = mapData.siloNukes;
                }
                if(mapData.nationList) {
                    nationList = mapData.nationList;
                    // Rebuild nation dropdown
                    const select = document.getElementById('armyNation');
                    select.innerHTML = '';
                    nationList.forEach(nation => {
                        const option = document.createElement('option');
                        option.value = nation;
                        option.textContent = nation;
                        select.appendChild(option);
                    });
                }
                redraw();
            }
        }
        
        function loadLastSave() {
            try {
                const savedData = localStorage.getItem('strategicMapSave');
                if(savedData) {
                    const mapData = JSON.parse(savedData);
                    loadMapData(mapData);
                    showStatus('Previous save loaded!', 'success');
                    return true;
                }
            } catch(error) {
                console.error('Error loading previous save:', error);
            }
            return false;
        }
        
        function clearMap() {
            if(confirm('Are you sure you want to clear all units?')) {
                units = {
                    armies: [],
                    railroads: [],
                    silos: [],
                    ports: []
                };
                siloNukes = {};
                redraw();
                showStatus('Map cleared!', 'success');
            }
        }
        
        function loadBackground() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/png,image/jpeg,image/jpg,image/gif,image/bmp,image/webp';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if(file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            backgroundImage = img;
                            camera.x = 0;
                            camera.y = 0;
                            camera.zoom = Math.min(canvas.width / img.width, canvas.height / img.height);
                            constrainCamera();
                            redraw();
                            showStatus('Background loaded!', 'success');
                        };
                        img.onerror = () => {
                            showStatus('Error loading image!', 'error');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function loadFlags() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = (e) => {
                const files = e.target.files;
                let loadedCount = 0;
                let totalFiles = files.length;
                
                if(totalFiles === 0) return;
                
                for(let file of files) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            // Extract nation name from filename (remove extension, make lowercase)
                            let nationName = file.name.split('.')[0].toLowerCase();
                            // Remove spaces and special characters
                            nationName = nationName.replace(/[^a-z0-9]/g, '');
                            
                            flagImages[nationName] = img;
                            loadedCount++;
                            
                            console.log(`Loaded flag: ${file.name} as "${nationName}"`);
                            
                            if(loadedCount === totalFiles) {
                                redraw();
                                showStatus(`${loadedCount} flag(s) loaded!`, 'success');
                                console.log('All flags loaded:', Object.keys(flagImages));
                            }
                        };
                        img.onerror = () => {
                            console.error(`Failed to load image: ${file.name}`);
                            loadedCount++;
                            if(loadedCount === totalFiles) {
                                redraw();
                                showStatus(`${Object.keys(flagImages).length} flag(s) loaded!`, 'success');
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.onerror = () => {
                        console.error(`Failed to read file: ${file.name}`);
                        loadedCount++;
                        if(loadedCount === totalFiles) {
                            redraw();
                            showStatus(`${Object.keys(flagImages).length} flag(s) loaded!`, 'success');
                        }
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }
        
        function zoomIn() {
            camera.zoom *= 1.2;
            constrainCamera();
            redraw();
        }
        
        function zoomOut() {
            camera.zoom /= 1.2;
            constrainCamera();
            redraw();
        }
        
        function resetView() {
            camera.x = 0;
            camera.y = 0;
            if(backgroundImage) {
                camera.zoom = Math.min(canvas.width / backgroundImage.width, canvas.height / backgroundImage.height);
            } else {
                camera.zoom = 1;
            }
            constrainCamera();
            redraw();
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            setTimeout(() => {
                status.textContent = '';
                status.className = 'status';
            }, 3000);
        }
        
        function initializeMap() {
            // Set canvas size to full window
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Try to load previous save first
            if(loadLastSave()) {
                return; // Previous save loaded successfully
            }
            
            // If no save, try to load default background
            const defaultImg = new Image();
            defaultImg.onload = () => {
                backgroundImage = defaultImg;
                camera.x = 0;
                camera.y = 0;
                camera.zoom = Math.min(canvas.width / defaultImg.width, canvas.height / defaultImg.height);
                constrainCamera();
                redraw();
                showStatus('Default map loaded!', 'success');
            };
            defaultImg.onerror = () => {
                redraw();
            };
            defaultImg.src = 'map.png';
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redraw();
        });
        
        initializeMap();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NationStates Manager v2.6</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0d0d0d;
            color: #b794f6;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }
        
        .console {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #1a1a1a;
            border: 2px solid #553c9a;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.3);
        }
        
        .header {
            text-align: center;
            color: #d6bcfa;
            margin-bottom: 20px;
            font-size: 18px;
            border-bottom: 1px solid #553c9a;
            padding-bottom: 10px;
        }
        
        .output {
            height: 400px;
            overflow-y: scroll;
            background-color: #000;
            border: 1px solid #553c9a;
            padding: 10px;
            margin-bottom: 10px;
            white-space: pre-wrap;
            font-size: 14px;
        }
        
        .input-line {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .prompt {
            color: #e9d5ff;
            margin-right: 5px;
        }
        
        #commandInput {
            flex: 1;
            background-color: #000;
            border: 1px solid #553c9a;
            color: #b794f6;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            padding: 5px 10px;
            outline: none;
        }
        
        #commandInput:focus {
            border-color: #9f7aea;
            box-shadow: 0 0 5px rgba(159, 122, 234, 0.5);
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background-color: #2d1b69;
            border: 1px solid #9f7aea;
            color: #d6bcfa;
            padding: 5px 15px;
            cursor: pointer;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
            border-radius: 4px;
        }
        
        button:hover {
            background-color: #553c9a;
            box-shadow: 0 0 5px rgba(159, 122, 234, 0.5);
        }

        .output::-webkit-scrollbar {
            width: 8px;
        }

        .output::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .output::-webkit-scrollbar-thumb {
            background: #553c9a;
            border-radius: 4px;
        }

        .output::-webkit-scrollbar-thumb:hover {
            background: #9f7aea;
        }
    </style>
</head>
<body>
    <div class="console">
        <div class="header">
            NationStates Manager v2.6 | Turn <span id="turnCounter">0</span> | Type 'commands' for help
        </div>
        
        <div id="output" class="output"></div>
        
        <div class="input-line">
            <span class="prompt">></span>
            <input type="text" id="commandInput" placeholder="Enter command..." autocomplete="off">
        </div>
        
        <div class="button-row">
            <button onclick="GameManager.executeCommand('nations')">Nations</button>
            <button onclick="GameManager.executeCommand('turn')">Next Turn</button>
            <button onclick="GameManager.executeCommand('commands')">Commands</button>
            <button onclick="GameManager.clearOutput()">Clear</button>
            <button onclick="GameManager.saveData()">Save</button>
            <button onclick="GameManager.loadData()">Load</button>
        </div>
    </div>

    <script>
        // Global GameManager object
        window.GameManager = (function() {
            // Game state
            let gameData = {
                nations: {},
                current_turn: 0,
                next_id: 1
            };
            
            let reminders = {};

            // Constants
            const PROVINCE_COSTS = {1: 5000, 2: 3500, 3: 2500, 4: 1500, 5: 1250};
            const CITY_COSTS = {1: 20000, 2: 15000, 3: 10000, 4: 5000, 5: 2500};
            const NUKE_COST = 250000;
            const SILO_COST = 100000;
            const MP_COST_PER_UNIT = 1;
            const PORT_COST = 15000;
            const BATTALION_SIZE = 2000;
            const DEPLOYMENT_COST = 0.5;
            const RAILROAD_COST = 1500;
            const MP_GENERATION = {1: 500, 2: 400, 3: 300, 4: 200, 5: 100};
            
            const POLICIES = {
                third: {
                    mp_cost_reduction: 0.2,
                    war_recovery: 0.66,
                    peace_recovery: 0.5,
                    peace_gpt_penalty: -0.15,
                    post_loss_penalty: -0.3,
                    post_loss_duration: 4
                },
                socialist: {
                    build_cost_reduction: 0.15,
                    manpower_boost: 0.1,
                    war_gpt_penalty: -0.2
                },
                capitalist: {
                    war_gpt_boost: 0.15,
                    expansion_discount: 150,
                    loan_penalty: 0.35,
                    upgrade_cost_increase: 0.15
                }
            };

            // Initialize
            function initializeNation(nation) {
                nation.at_war = nation.at_war || false;
                nation.mp_losses = nation.mp_losses || 0;
                nation.loans = nation.loans || [];
                nation.provinces = nation.provinces || [];
                nation.cities = nation.cities || [];
                nation.ports = nation.ports || 0;
                nation.nukes = nation.nukes || 0;
                nation.silos = nation.silos || 0;
                nation.mp_pool = nation.mp_pool || 25000;
                nation.recruited_mp = nation.recruited_mp || 10000;
                nation.deployed_mp = nation.deployed_mp || 0;
                nation.battalions = Math.floor(nation.recruited_mp / BATTALION_SIZE);
                nation.railroads = nation.railroads || 0;
                nation.debuffs = nation.debuffs || [];
                nation.policy = nation.policy || null;
                nation.post_loss_turns = nation.post_loss_turns || 0;
                nation.war_history = nation.war_history || [];
                return nation;
            }

            // Output functions
            function print(message) {
                const output = document.getElementById('output');
                output.textContent += message + '\n';
                output.scrollTop = output.scrollHeight;
            }

            function updateTurnCounter() {
                document.getElementById('turnCounter').textContent = gameData.current_turn;
            }

            // Utility functions
            function calculateGPT(nation) {
                const provinceIncome = nation.provinces.reduce((sum, p) => 
                    sum + ({1: 1000, 2: 700, 3: 500, 4: 300, 5: 250}[p.level] || 0), 0);
                const cityIncome = nation.cities.reduce((sum, c) => 
                    sum + ({1: 2000, 2: 1500, 3: 1000, 4: 500, 5: 250}[c.level] || 0), 0);
                
                const totalDebuff = Math.min(nation.debuffs.reduce((sum, d) => sum + d.percent, 0), 100);
                const baseGPT = provinceIncome + cityIncome;
                let grossIncome = Math.floor(baseGPT * (100 - totalDebuff) / 100);
                
                const policy = nation.policy;
                if (policy === 'third') {
                    if (!nation.at_war) {
                        grossIncome *= (1 + POLICIES.third.peace_gpt_penalty);
                    }
                    if (nation.post_loss_turns > 0) {
                        grossIncome *= (1 + POLICIES.third.post_loss_penalty);
                    }
                } else if (policy === 'socialist' && nation.at_war) {
                    grossIncome *= (1 + POLICIES.socialist.war_gpt_penalty);
                } else if (policy === 'capitalist' && nation.at_war) {
                    grossIncome *= (1 + POLICIES.capitalist.war_gpt_boost);
                }
                
                return Math.floor(grossIncome);
            }

            // Command handlers
            const commands = {
                // Nation management
                addnation: function(args) {
                    if (args.length < 2) {
                        print("Usage: addnation [name] [color]");
                        return;
                    }
                    const name = args.slice(0, -1).join(' ');
                    const color = args[args.length - 1];
                    const nationId = gameData.next_id.toString();
                    
                    gameData.nations[nationId] = initializeNation({
                        name: name,
                        color: color,
                        gold: 50000,
                        mp: 25000
                    });
                    gameData.next_id++;
                    print(`Created ${name} (ID: ${nationId})`);
                },

                removenation: function(args) {
                    if (args.length !== 1 || !gameData.nations[args[0]]) {
                        print("Usage: removenation [id]");
                        return;
                    }
                    const name = gameData.nations[args[0]].name;
                    delete gameData.nations[args[0]];
                    print(`Removed ${name} (ID: ${args[0]})`);
                },

                nations: function(args) {
                    print("\n=== NATIONS ===");
                    for (const [id, nation] of Object.entries(gameData.nations)) {
                        const gpt = calculateGPT(nation);
                        const debuffs = nation.debuffs.reduce((sum, d) => sum + d.percent, 0);
                        const policy = (nation.policy || 'None').charAt(0).toUpperCase() + (nation.policy || 'None').slice(1);
                        
                        print(`\nID: ${id} | ${nation.name} [${nation.at_war ? 'WAR' : 'Peace'}]`);
                        print(`Policy: ${policy}`);
                        print(`Gold: ${nation.gold} (+${gpt}/turn)${debuffs ? ` (-${debuffs}% debuff)` : ''}`);
                        print(`Manpower Pool: ${nation.mp_pool}`);
                        print(`Military:`);
                        print(`  Deployed: ${nation.deployed_mp} MP (${Math.floor(nation.deployed_mp/BATTALION_SIZE)} battalions)`);
                        print(`  Reserve: ${nation.recruited_mp - nation.deployed_mp} MP (${Math.floor((nation.recruited_mp - nation.deployed_mp)/BATTALION_SIZE)} battalions)`);
                        print(`  Losses: ${nation.mp_losses} MP`);
                        print(`Ports: ${nation.ports}`);
                        print(`Nukes: ${nation.nukes} | Silos: ${nation.silos} | Railroads: ${nation.railroads}`);
                        print(`Provinces: ${nation.provinces.length} | Cities: ${nation.cities.length}`);
                    }
                },

                provinces: function(args) {
                    if (args.length !== 1 || !gameData.nations[args[0]]) {
                        print("Usage: provinces [id]");
                        return;
                    }
                    
                    const nation = gameData.nations[args[0]];
                    const provinceCounts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
                    const cityCounts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0};
                    
                    nation.provinces.forEach(p => provinceCounts[p.level]++);
                    nation.cities.forEach(c => cityCounts[c.level]++);
                    
                    print(`\n${nation.name}`);
                    print("PROVINCES");
                    for (let level = 1; level <= 5; level++) {
                        print(`${level}: ${provinceCounts[level]}`);
                    }
                    
                    print("\nCITIES");
                    for (let level = 1; level <= 5; level++) {
                        print(`${level}: ${cityCounts[level]}`);
                    }
                },

                // Province management
                buyprovince: function(args) {
                    if (args.length !== 3) {
                        print("Usage: buyprovince [id] [level] [amount]");
                        return;
                    }
                    
                    const [nationId, level, amount] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !PROVINCE_COSTS[level]) {
                        print("Invalid nation ID or province level (1-5)");
                        return;
                    }
                    
                    const cost = PROVINCE_COSTS[level] * amount;
                    const nation = gameData.nations[nationId];
                    
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        for (let i = 0; i < amount; i++) {
                            nation.provinces.push({
                                level: level,
                                mp_generation: MP_GENERATION[level]
                            });
                        }
                        print(`Bought ${amount} level ${level} provinces for ${cost} gold`);
                    } else {
                        print("Not enough gold");
                    }
                },

                addprovince: function(args) {
                    if (args.length !== 3) {
                        print("Usage: addprovince [id] [level] [amount]");
                        return;
                    }
                    
                    const [nationId, level, amount] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !PROVINCE_COSTS[level]) {
                        print("Invalid nation ID or province level (1-5)");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    for (let i = 0; i < amount; i++) {
                        nation.provinces.push({
                            level: level,
                            mp_generation: MP_GENERATION[level]
                        });
                    }
                    print(`Added ${amount} level ${level} provinces (admin)`);
                },

                removeprovince: function(args) {
                    if (args.length !== 3) {
                        print("Usage: removeprovince [id] [level] [amount]");
                        return;
                    }
                    
                    const [nationId, level, amount] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !PROVINCE_COSTS[level]) {
                        print("Invalid nation ID or province level (1-5)");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    let removed = 0;
                    for (let i = nation.provinces.length - 1; i >= 0 && removed < amount; i--) {
                        if (nation.provinces[i].level === level) {
                            nation.provinces.splice(i, 1);
                            removed++;
                        }
                    }
                    print(`Removed ${removed} level ${level} provinces`);
                },

                renovateprovince: function(args) {
                    if (args.length !== 4) {
                        print("Usage: renovateprovince [id] [current_level] [new_level] [amount]");
                        return;
                    }
                    
                    const [nationId, currentLevel, newLevel, amount] = [args[0], parseInt(args[1]), parseInt(args[2]), parseInt(args[3])];
                    if (!gameData.nations[nationId] || !PROVINCE_COSTS[currentLevel] || !PROVINCE_COSTS[newLevel] || newLevel >= currentLevel) {
                        print("Error: Invalid province levels (must upgrade to higher level)");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const cost = (PROVINCE_COSTS[newLevel] - PROVINCE_COSTS[currentLevel]) * amount;
                    const matching = nation.provinces.filter(p => p.level === currentLevel);
                    
                    if (matching.length < amount) {
                        print(`Only ${matching.length} level ${currentLevel} provinces (need ${amount})`);
                        return;
                    }
                    
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        let upgraded = 0;
                        for (const p of nation.provinces) {
                            if (p.level === currentLevel && upgraded < amount) {
                                p.level = newLevel;
                                p.mp_generation = MP_GENERATION[newLevel];
                                upgraded++;
                            }
                        }
                        print(`Renovated ${amount} provinces from level ${currentLevel} to ${newLevel} for ${cost} gold`);
                    } else {
                        print(`Need ${cost} gold, but only have ${nation.gold}`);
                    }
                },

                upgradeprovince: function(args) {
                    if (args.length !== 4) {
                        print("Usage: upgradeprovince [id] [current_level] [new_level] [amount]");
                        return;
                    }
                    
                    const [nationId, currentLevel, newLevel, amount] = [args[0], parseInt(args[1]), parseInt(args[2]), parseInt(args[3])];
                    if (!gameData.nations[nationId] || !PROVINCE_COSTS[currentLevel] || !PROVINCE_COSTS[newLevel] || newLevel >= currentLevel) {
                        print("Error: Invalid province levels (must upgrade to higher level)");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const matching = nation.provinces.filter(p => p.level === currentLevel);
                    
                    if (matching.length < amount) {
                        print(`Only ${matching.length} level ${currentLevel} provinces (need ${amount})`);
                        return;
                    }
                    
                    let upgraded = 0;
                    for (const p of nation.provinces) {
                        if (p.level === currentLevel && upgraded < amount) {
                            p.level = newLevel;
                            p.mp_generation = MP_GENERATION[newLevel];
                            upgraded++;
                        }
                    }
                    print(`Upgraded ${amount} provinces from level ${currentLevel} to ${newLevel} (admin)`);
                },

                // City management
                buildcity: function(args) {
                    if (args.length !== 3) {
                        print("Usage: buildcity [id] [city_level] [tile_level]");
                        return;
                    }
                    
                    const [nationId, cityLevel, tileLevel] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !CITY_COSTS[cityLevel] || !PROVINCE_COSTS[tileLevel]) {
                        print("Error: Both city and tile levels must be 1-5");
                        return;
                    }
                    
                    const cost = CITY_COSTS[cityLevel];
                    const nation = gameData.nations[nationId];
                    
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        nation.cities.push({
                            level: cityLevel,
                            tile_level: tileLevel
                        });
                        print(`Built level ${cityLevel} city on level ${tileLevel} tile for ${cost} gold`);
                    } else {
                        print(`Error: Need ${cost} gold, but only have ${nation.gold}`);
                    }
                },

                addcity: function(args) {
                    if (args.length !== 3) {
                        print("Usage: addcity [id] [city_level] [tile_level]");
                        return;
                    }
                    
                    const [nationId, cityLevel, tileLevel] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !CITY_COSTS[cityLevel] || !PROVINCE_COSTS[tileLevel]) {
                        print("Error: Both city and tile levels must be 1-5");
                        return;
                    }
                    
                    gameData.nations[nationId].cities.push({
                        level: cityLevel,
                        tile_level: tileLevel
                    });
                    print(`Added level ${cityLevel} city on level ${tileLevel} tile (admin)`);
                },

                renovatecity: function(args) {
                    if (args.length !== 3) {
                        print("Usage: renovatecity [id] [current_level] [new_level]");
                        return;
                    }
                    
                    const [nationId, currentLevel, newLevel] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !CITY_COSTS[currentLevel] || !CITY_COSTS[newLevel] || newLevel >= currentLevel) {
                        print("Error: Invalid city levels (must upgrade to higher level)");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const cost = CITY_COSTS[newLevel] - CITY_COSTS[currentLevel];
                    
                    const city = nation.cities.find(c => c.level === currentLevel);
                    if (city) {
                        if (nation.gold >= cost) {
                            nation.gold -= cost;
                            city.level = newLevel;
                            print(`Renovated city from level ${currentLevel} to ${newLevel} for ${cost} gold`);
                        } else {
                            print(`Need ${cost} gold, but only have ${nation.gold}`);
                        }
                    } else {
                        print(`No level ${currentLevel} city found`);
                    }
                },

                upgradecity: function(args) {
                    if (args.length !== 3) {
                        print("Usage: upgradecity [id] [current_level] [new_level]");
                        return;
                    }
                    
                    const [nationId, currentLevel, newLevel] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId] || !CITY_COSTS[currentLevel] || !CITY_COSTS[newLevel] || newLevel >= currentLevel) {
                        print("Error: Invalid city levels (must upgrade to higher level)");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const city = nation.cities.find(c => c.level === currentLevel);
                    if (city) {
                        city.level = newLevel;
                        print(`Upgraded city from level ${currentLevel} to ${newLevel} (admin)`);
                    } else {
                        print(`No level ${currentLevel} city found`);
                    }
                },

                removecity: function(args) {
                    if (args.length !== 4) {
                        print("Usage: removecity [id] [city_level] [tile_level] [amount]");
                        return;
                    }
                    
                    const [nationId, cityLevel, tileLevel, amount] = [args[0], parseInt(args[1]), parseInt(args[2]), parseInt(args[3])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    let removed = 0;
                    
                    for (let i = nation.cities.length - 1; i >= 0 && removed < amount; i--) {
                        const city = nation.cities[i];
                        if (city.level === cityLevel && city.tile_level === tileLevel) {
                            nation.cities.splice(i, 1);
                            removed++;
                        }
                    }
                    
                    print(`Removed ${removed} level ${cityLevel} cities on level ${tileLevel} tiles`);
                    if (removed < amount) {
                        print(`Warning: Only found ${removed} matching cities (tried to remove ${amount})`);
                    }
                },

                // Military
                war: function(args) {
                    if (args.length < 1 || !gameData.nations[args[0]]) {
                        print("Usage: war [id] [won/lost/tie (optional)]");
                        return;
                    }
                    
                    const nation = gameData.nations[args[0]];
                    const declaringWar = !nation.at_war;
                    
                    nation.at_war = !nation.at_war;
                    
                    if (declaringWar) {
                        nation.deployed_mp = nation.recruited_mp;
                        print(`All ${nation.battalions} battalions automatically deployed!`);
                    }
                    
                    if (args.length >= 2) {
                        const outcome = args[1].toLowerCase();
                        if (['won', 'lost', 'tie'].includes(outcome)) {
                            nation.war_history.push({
                                turn: gameData.current_turn,
                                outcome: outcome
                            });
                            if (outcome === 'lost' && nation.policy === 'third') {
                                nation.post_loss_turns = POLICIES.third.post_loss_duration;
                                print(`Vampire Economy activated! -30% GPT for ${POLICIES.third.post_loss_duration} turns`);
                            }
                        }
                    }
                    
                    if (!nation.at_war) {
                        nation.deployed_mp = 0;
                        print("All battalions demobilized during peace");
                    }
                    
                    const status = nation.at_war ? "now at war" : "no longer at war";
                    print(`${nation.name} is ${status}`);
                },

                buymp: function(args) {
                    if (args.length !== 2) {
                        print("Usage: buymp [id] [battalions]");
                        return;
                    }
                    
                    const [nationId, battalions] = [args[0], parseInt(args[1])];
                    const nation = gameData.nations[nationId];
                    if (!nation) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const mpCost = battalions * BATTALION_SIZE * MP_COST_PER_UNIT;
                    
                    if (nation.mp_pool >= battalions * BATTALION_SIZE) {
                        if (nation.gold >= mpCost) {
                            nation.gold -= mpCost;
                            nation.mp_pool -= battalions * BATTALION_SIZE;
                            nation.recruited_mp += battalions * BATTALION_SIZE;
                            nation.battalions = Math.floor(nation.recruited_mp / BATTALION_SIZE);
                            print(`Recruited ${battalions} battalions for ${mpCost} gold`);
                        } else {
                            print(`Need ${mpCost} gold, have ${nation.gold}`);
                        }
                    } else {
                        print(`Not enough MP in pool (need ${battalions * BATTALION_SIZE}, have ${nation.mp_pool})`);
                    }
                },

                deploy: function(args) {
                    if (args.length !== 2) {
                        print("Usage: deploy [id] [battalions]");
                        return;
                    }
                    
                    const [nationId, battalions] = [args[0], parseInt(args[1])];
                    const nation = gameData.nations[nationId];
                    if (!nation) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const available = nation.recruited_mp - nation.deployed_mp;
                    const maxDeploy = Math.floor(available / BATTALION_SIZE);
                    
                    if (battalions <= maxDeploy) {
                        nation.deployed_mp += battalions * BATTALION_SIZE;
                        print(`Deployed ${battalions} battalions (${battalions * BATTALION_SIZE} MP)`);
                    } else {
                        print(`Only ${maxDeploy} battalions available to deploy`);
                    }
                },

                killmp: function(args) {
                    if (args.length !== 2) {
                        print("Usage: killmp [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const killed = Math.min(amount, nation.recruited_mp);
                    
                    // Remove from recruited MP first
                    nation.recruited_mp -= killed;
                    nation.mp_losses += killed;
                    
                    // If deployed MP exceeds new recruited MP, reduce deployed MP
                    if (nation.deployed_mp > nation.recruited_mp) {
                        nation.deployed_mp = nation.recruited_mp;
                    }
                    
                    // Update battalion count
                    nation.battalions = Math.floor(nation.recruited_mp / BATTALION_SIZE);
                    
                    print(`Killed ${killed} MP from reserve/deploy pool (tracking for regeneration)`);
                },

                removemppool: function(args) {
                    if (args.length !== 2) {
                        print("Usage: removemppool [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const removed = Math.min(amount, nation.mp_pool);
                    nation.mp_pool -= removed;
                    print(`Removed ${removed} MP from manpower pool`);
                },

                removemp: function(args) {
                    if (args.length !== 2) {
                        print("Usage: removemp [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const removed = Math.min(amount, nation.recruited_mp);
                    
                    // Remove from recruited MP
                    nation.recruited_mp -= removed;
                    
                    // If deployed MP exceeds new recruited MP, reduce deployed MP
                    if (nation.deployed_mp > nation.recruited_mp) {
                        nation.deployed_mp = nation.recruited_mp;
                    }
                    
                    // Update battalion count
                    nation.battalions = Math.floor(nation.recruited_mp / BATTALION_SIZE);
                    
                    print(`Removed ${removed} MP from reserve/deploy pool (admin)`);
                },

                addbattalion: function(args) {
                    if (args.length !== 2) {
                        print("Usage: addbattalion [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const mpAdded = amount * BATTALION_SIZE;
                    nation.recruited_mp += mpAdded;
                    nation.battalions = Math.floor(nation.recruited_mp / BATTALION_SIZE);
                    print(`Added ${amount} battalions (${mpAdded} MP) to reserve/deploy pool (admin)`);
                },

                addmppool: function(args) {
                    if (args.length !== 2) {
                        print("Usage: addmppool [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    nation.mp_pool += amount;
                    print(`Added ${amount} MP to manpower pool (admin)`);
                },

                // Infrastructure
                buildport: function(args) {
                    if (args.length !== 2) {
                        print("Usage: buildport [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const cost = amount * PORT_COST;
                    
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        nation.ports += amount;
                        print(`Built ${amount} port(s) for ${cost} gold`);
                    } else {
                        print(`Need ${cost} gold, only have ${nation.gold}`);
                    }
                },

                addport: function(args) {
                    if (args.length !== 2) {
                        print("Usage: addport [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    gameData.nations[nationId].ports += amount;
                    print(`Added ${amount} port(s) (admin)`);
                },

                buildrr: function(args) {
                    if (args.length !== 2) {
                        print("Usage: buildrr [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    const nation = gameData.nations[nationId];
                    if (!nation) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const cost = amount * RAILROAD_COST;
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        nation.railroads += amount;
                        print(`Built ${amount} railroads for ${cost} gold`);
                    } else {
                        print("Not enough gold");
                    }
                },

                createrr: function(args) {
                    if (args.length !== 2) {
                        print("Usage: createrr [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    gameData.nations[nationId].railroads += amount;
                    print(`Added ${amount} railroads (admin)`);
                },

                destroyrr: function(args) {
                    if (args.length !== 2) {
                        print("Usage: destroyrr [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    const nation = gameData.nations[nationId];
                    if (!nation) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const removed = Math.min(amount, nation.railroads);
                    nation.railroads -= removed;
                    print(`Permanently destroyed ${removed} railroads (no refund)`);
                },

                // Nuclear weapons
                buildnuke: function(args) {
                    if (args.length !== 2) {
                        print("Usage: buildnuke [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const cost = amount * NUKE_COST;
                    const nation = gameData.nations[nationId];
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        nation.nukes += amount;
                        print(`Built ${amount} nukes for ${cost} gold`);
                    } else {
                        print("Not enough gold");
                    }
                },

                addnuke: function(args) {
                    if (args.length !== 2) {
                        print("Usage: addnuke [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    gameData.nations[nationId].nukes += amount;
                    print(`Added ${amount} nukes to ${gameData.nations[nationId].name}`);
                },

                nuke: function(args) {
                    if (args.length !== 2) {
                        print("Usage: nuke [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    if (nation.nukes >= amount) {
                        nation.nukes -= amount;
                        print(`Used ${amount} nukes from ${nation.name}`);
                    } else {
                        print("Not enough nukes");
                    }
                },

                buysilo: function(args) {
                    if (args.length !== 2) {
                        print("Usage: buysilo [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const cost = amount * SILO_COST;
                    const nation = gameData.nations[nationId];
                    if (nation.gold >= cost) {
                        nation.gold -= cost;
                        nation.silos += amount;
                        print(`Built ${amount} silos for ${cost} gold`);
                    } else {
                        print("Not enough gold");
                    }
                },

                buildsilo: function(args) {
                    if (args.length !== 2) {
                        print("Usage: buildsilo [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    gameData.nations[nationId].silos += amount;
                    print(`Added ${amount} silos to ${gameData.nations[nationId].name} (admin)`);
                },

                // Economy
                loan: function(args) {
                    if (args.length !== 2) {
                        print("Usage: loan [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    const nation = gameData.nations[nationId];
                    const gpt = calculateGPT(nation);
                    const maxLoan = Math.floor(gpt / 2);
                    
                    if (amount <= maxLoan) {
                        nation.gold += amount;
                        nation.loans.push({
                            amount: amount,
                            due_turn: gameData.current_turn + 3,
                            repaid: false
                        });
                        print(`Loan of ${amount} gold given. Repay ${Math.floor(amount * 1.3)} by turn ${gameData.current_turn + 3}`);
                    } else {
                        print(`Maximum loan is ${maxLoan} (half of GPT)`);
                    }
                },

                addgold: function(args) {
                    if (args.length !== 2) {
                        print("Usage: addgold [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid ID");
                        return;
                    }
                    
                    gameData.nations[nationId].gold += amount;
                    print(`Added ${amount} gold`);
                },

                removegold: function(args) {
                    if (args.length !== 2) {
                        print("Usage: removegold [id] [amount]");
                        return;
                    }
                    
                    const [nationId, amount] = [args[0], parseInt(args[1])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid ID");
                        return;
                    }
                    
                    gameData.nations[nationId].gold = Math.max(0, gameData.nations[nationId].gold - amount);
                    print(`Removed ${amount} gold`);
                },

                // Policies and effects
                setpolicy: function(args) {
                    if (args.length !== 2) {
                        print("Usage: setpolicy [id] [socialist/capitalist/third]");
                        return;
                    }
                    
                    const [nationId, policy] = [args[0], args[1].toLowerCase()];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    if (POLICIES[policy]) {
                        gameData.nations[nationId].policy = policy;
                        print(`${gameData.nations[nationId].name} is now ${policy.toUpperCase()}`);
                        print(`Effects: ${JSON.stringify(POLICIES[policy])}`);
                    } else {
                        print("Invalid policy (socialist/capitalist/third)");
                    }
                },

                debuff: function(args) {
                    if (args.length !== 3) {
                        print("Usage: debuff [id] [percent] [turns]");
                        return;
                    }
                    
                    const [nationId, percent, turns] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    if (percent >= 0 && percent <= 100) {
                        gameData.nations[nationId].debuffs.push({
                            percent: percent,
                            expires: gameData.current_turn + turns
                        });
                        print(`Applied ${percent}% GPT debuff for ${turns} turns`);
                    } else {
                        print("Percent must be 0-100");
                    }
                },

                buff: function(args) {
                    if (args.length !== 3) {
                        print("Usage: buff [id] [percent] [turns]");
                        return;
                    }
                    
                    const [nationId, percent, turns] = [args[0], parseInt(args[1]), parseInt(args[2])];
                    if (!gameData.nations[nationId]) {
                        print("Invalid nation ID");
                        return;
                    }
                    
                    if (percent >= 1 && percent <= 100 && turns > 0) {
                        gameData.nations[nationId].debuffs.push({
                            percent: -percent,
                            expires: gameData.current_turn + turns
                        });
                        print(`Added +${percent}% GPT boost for ${turns} turns to ${gameData.nations[nationId].name}`);
                    } else {
                        print("Percent must be 1-100 and turns must be positive");
                    }
                },

                // Utility
                reminder: function(args) {
                    if (args.length < 2) {
                        print("Usage: reminder [turns] \"[message]\"");
                        return;
                    }
                    
                    const turns = parseInt(args[0]);
                    const message = args.slice(1).join(' ');
                    
                    if (turns <= 0) {
                        print("Turn count must be positive");
                        return;
                    }
                    if (!message.trim()) {
                        print("Message cannot be empty");
                        return;
                    }
                    
                    const triggerTurn = gameData.current_turn + turns;
                    if (!reminders[triggerTurn]) {
                        reminders[triggerTurn] = [];
                    }
                    reminders[triggerTurn].push(message);
                    print(`Reminder set for turn ${triggerTurn}: "${message}"`);
                },

                reset: function(args) {
                    if (args.length === 0) {
                        print("Usage: reset [turn] [gold] [mp] [provinces]");
                        return;
                    }
                    
                    print("\nWARNING: This will permanently reset:");
                    if (args.includes("turn")) print("- Turn counter to 1");
                    if (args.includes("gold")) print("- All nations' gold to 10,000");
                    if (args.includes("mp")) print("- All nations' MP to 10,000 (5 battalions)");
                    if (args.includes("provinces")) print("- All nations' provinces to starting state");
                    
                    if (confirm("Are you sure? This cannot be undone!")) {
                        if (args.includes("provinces")) {
                            gameData.current_turn = 0;
                            for (const nation of Object.values(gameData.nations)) {
                                nation.gold = 40000;
                                nation.mp = 25000;
                                nation.provinces = [];
                                nation.cities = [];
                                nation.loans = [];
                                nation.at_war = false;
                                nation.mp_losses = 0;
                                nation.nukes = 0;
                                nation.silos = 0;
                                nation.debuffs = [];
                            }
                        } else {
                            if (args.includes("turn")) {
                                gameData.current_turn = 0;
                            }
                            for (const nation of Object.values(gameData.nations)) {
                                if (args.includes("gold")) {
                                    nation.gold = 50000;
                                }
                                if (args.includes("mp")) {
                                    nation.mp = 25000;
                                }
                            }
                        }
                        updateTurnCounter();
                        print("Reset completed");
                    } else {
                        print("Reset cancelled");
                    }
                },

                turn: function(args) {
                    gameData.current_turn++;
                    updateTurnCounter();
                    print(`\n=== TURN ${gameData.current_turn} ===`);
                    
                    for (const nation of Object.values(gameData.nations)) {
                        // 1. MP Generation (every 5 turns)
                        if (gameData.current_turn % 5 === 0) {
                            const mpGenerated = nation.provinces.reduce((sum, p) => sum + p.mp_generation, 0);
                            if (mpGenerated > 0) {
                                nation.mp_pool += mpGenerated;
                                print(`${nation.name} generated ${mpGenerated} MP to pool`);
                            }
                        }
                        
                        // 2. Deployment Maintenance Costs
                        if (nation.deployed_mp > 0) {
                            const cost = Math.floor(nation.deployed_mp * DEPLOYMENT_COST);
                            nation.gold -= cost;
                            print(`${nation.name} paid ${cost}g for deployed troops`);
                        }

                        // 3. Gold Income and Policy Modifiers
                        let grossIncome = calculateGPT(nation);
                        const policy = nation.policy;
                        
                        if (policy === 'third') {
                            if (!nation.at_war) {
                                grossIncome *= (1 + POLICIES.third.peace_gpt_penalty);
                            }
                            if (nation.post_loss_turns > 0) {
                                grossIncome *= (1 + POLICIES.third.post_loss_penalty);
                                nation.post_loss_turns--;
                            }
                        } else if (policy === 'socialist' && nation.at_war) {
                            grossIncome *= (1 + POLICIES.socialist.war_gpt_penalty);
                        } else if (policy === 'capitalist' && nation.at_war) {
                            grossIncome *= (1 + POLICIES.capitalist.war_gpt_boost);
                        }
                        
                        nation.gold += Math.floor(grossIncome);
                        
                        // 4. Loan Repayment
                        for (const loan of nation.loans) {
                            if (!loan.repaid && gameData.current_turn >= loan.due_turn) {
                                const repayment = Math.floor(loan.amount * 1.3);
                                if (nation.gold >= repayment) {
                                    nation.gold -= repayment;
                                    loan.repaid = true;
                                    print(`${nation.name} repaid ${repayment} gold`);
                                } else {
                                    const penalty = policy === 'capitalist' ? POLICIES.capitalist.loan_penalty : 0.25;
                                    const penaltyGold = Math.floor(nation.gold * penalty);
                                    nation.gold -= penaltyGold;
                                    print(`${nation.name} defaulted! Lost ${penaltyGold} gold (${Math.floor(penalty*100)}% penalty)`);
                                }
                            }
                        }

                        // 5. MP Recovery (to pool)
                        if (nation.mp_losses > 0) {
                            let recoveryRate;
                            if (policy === 'third') {
                                recoveryRate = nation.at_war ? POLICIES.third.war_recovery : POLICIES.third.peace_recovery;
                            } else {
                                recoveryRate = nation.at_war ? 0.33 : 0.25;
                            }
                            
                            const recovered = Math.floor(nation.mp_losses * recoveryRate);
                            nation.mp_pool += recovered;
                            nation.mp_losses -= recovered;
                            if (recovered > 0) {
                                print(`${nation.name} recovered ${recovered} MP to pool`);
                            }
                        }
                        
                        // Process debuffs
                        nation.debuffs = nation.debuffs.filter(d => d.expires > gameData.current_turn);
                    }
                    
                    // Check reminders
                    const currentTurn = gameData.current_turn.toString();
                    if (reminders[currentTurn]) {
                        print("\n=== REMINDERS ===");
                        for (const msg of reminders[currentTurn]) {
                            print(`- ${msg}`);
                        }
                        delete reminders[currentTurn];
                    }
                    
                    print("Turn processed!");
                },

                commands: function(args) {
                    print("\n=== NORMAL COMMANDS ===");
                    print("Nation Management:");
                    print("  provinces [id] - Show province/city distribution by level");
                    print("  setpolicy [id] [socialist/capitalist/third]");
                    print("  addnation [name] [color]");
                    print("\nProvinces:");
                    print("  buyprovince [id] [level] [amount]");
                    print("  buildport [id] [amount] - Build ports (15000g each)");
                    print("  renovateprovince [id] [current] [new] [amount]");
                    print("\nCities:");
                    print("  buildcity [id] [level] [tile_level]");
                    print("  renovatecity [id] [current] [new]");
                    print("\nMilitary:");
                    print("  war [id]");
                    print("  buymp [id] [amount]");
                    print("  killmp [id] [amount]");
                    print("\nNukes:");
                    print("  buildnuke [id] [amount]");
                    print("  nuke [id] [amount]");
                    print("  deploy [id] [amount]");
                    print("  buysilo [id] [amount]");
                    print("\nEconomy:");
                    print("  loan [id] [amount]");
                    print("  buildrr [id] [amount] - Railroads (1500g each)");
                    print("\nUtility:");
                    print("  reminder [turns] [message]");
                    print("  nations");
                    print("  turn");
                    print("  commands");

                    print("\n=== ADMIN COMMANDS ===");
                    print("  removenation [id]");
                    print("  reset [options]");
                    print("  addprovince [id] [level] [amount]");
                    print("  removeprovince [id] [level] [amount]");
                    print("  upgradeprovince [id] [current] [new] [amount]");
                    print("  addcity [id] [level] [tile_level]");
                    print("  upgradecity [id] [current] [new]");
                    print("  removecity [id] [city_level] [tile_level] [amount] - Remove cities (admin)");
                    print("  addbattalion [id] [amount] - Adds battalions (admin)");
                    print("  addmppool [id] [amount] - Adds to MP pool (admin)");
                    print("  removemppool [id] [amount] - Removes MP from pool (admin)");
                    print("  removemp [id] [amount] - Removes MP from reserve/deploy pool (admin)");
                    print("  destroyrr [id] [amount] - Permanent removal");
                    print("  buff [id] [percent] [turns]");
                    print("  addport [id] [amount] - Add ports (admin)");
                    print("  debuff [id] [percent] [turns]");
                    print("  addnuke [id] [amount]");
                    print("  removecity [id] [city_level] [tile_level] [amount] - Remove cities (admin)");
                    print("  buildsilo [id] [amount]");
                    print("  addgold [id] [amount]");
                    print("  removegold [id] [amount]");
                    print("  createrr [id] [amount] - Railroads (admin)");
                }
            };

            // Public interface
            return {
                executeCommand: function(input) {
                    const parts = input.trim().split(' ');
                    if (parts.length === 0 || parts[0] === '') return;
                    
                    const command = parts[0].toLowerCase();
                    const args = parts.slice(1);
                    
                    if (commands[command]) {
                        try {
                            commands[command](args);
                        } catch (error) {
                            print(`Error executing command: ${error.message}`);
                        }
                    } else {
                        print("Invalid command. Type 'commands' for help.");
                    }
                },

                saveData: function() {
                    const saveDataObj = {
                        gameData: gameData,
                        reminders: reminders
                    };
                    localStorage.setItem('nationstates_save', JSON.stringify(saveDataObj));
                    print("Game saved to browser storage");
                },

                loadData: function() {
                    const saved = localStorage.getItem('nationstates_save');
                    if (saved) {
                        try {
                            const data = JSON.parse(saved);
                            gameData = data.gameData || gameData;
                            reminders = data.reminders || {};
                            
                            // Initialize any missing nation properties
                            for (const nation of Object.values(gameData.nations)) {
                                initializeNation(nation);
                            }
                            
                            updateTurnCounter();
                            print("Game loaded from browser storage");
                        } catch (error) {
                            print("Error loading saved data");
                        }
                    } else {
                        print("No saved data found");
                    }
                },

                clearOutput: function() {
                    document.getElementById('output').textContent = '';
                }
            };
        })();

        // Event handlers
        document.addEventListener('DOMContentLoaded', function() {
            const commandInput = document.getElementById('commandInput');
            
            commandInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const input = this.value.trim();
                    if (input) {
                        print(`> ${input}`);
                        GameManager.executeCommand(input);
                        this.value = '';
                    }
                }
            });

            // Initialize
            const output = document.getElementById('output');
            output.textContent = "NationStates Manager v2.6 loaded\nType 'commands' for help or 'addnation [name] [color]' to create your first nation\n";
            
            // Auto-save every 30 seconds
            setInterval(() => {
                if (Object.keys(GameManager.gameData || {}).length > 0) {
                    GameManager.saveData();
                }
            }, 30000);
        });
    </script>
</body>
</html>
